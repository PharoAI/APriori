"
I am a model of an association rule - a rule that consists of two itemsets and states that if the left hand side itemset (key) appears in transaction, then the right hand side itemset (value) is also likely to appear in transaction. I can be used in a recommendation system. Consider two rules in the following example:

{bread, butter} => {avocado}
{tea, honey} => {sugar, lemon}

They can be interpreted like this: ""customer who bought bread and butter is also likely to buy an avocado, and a customer who bought tea and honey is likely to buy sugar and lemon"".

I store two itemsets as key and value of the association. I also know my count, support, confidence, and lift (A => B):

* count - number of transactions that contain all items of the itemset constructed by joining my right and left hand side itemsets
* support - the probability that a randomly picked transaction contains all items of that itemset: P(AB).
* confidence - conditional probability that all items from my right hand side itemset appear in transaction which contains all elemens of my left hand side itemset: P(B|A)
* lift - a correlation measure between my left and right hand side itemsets. It assesses the degree to which the occurence of items in the left itemset 'lifts' (increases) the likelihood of items from the right itemset to appear.

Association rules are generated by the APriori algorithm. My key and value are instances of Itemset. I can be encoded by replcing all items with integers using ItemsetEncoder. 

You can create my instances by sending the => message to an itemset and passing another itemset as an argument.

For example:

rule1 := #(bread butter) asItemset => #(avocado) asItemset.
rule2 := #(tea honey) asItemset => #(sugar lemon) asItemset.

I am printed as an association of two sets of items:

{bread, butter} => {avocado}
{tea, honey} => {sugar, lemon}

You can ask me for my:

- count
- support
- confidence
- lift

You can convert me to an itemset using my asItemset message - it will unite the itemsets in my left and right hand sides:

rule1 asItemset. ""{bread, butter, avocado}""
rule2 asItemset. ""{tea, honey, sugar, lemon}""
"
Class {
	#name : #AssociationRule,
	#superclass : #Association,
	#instVars : [
		'count',
		'support',
		'confidence',
		'lift'
	],
	#category : #APriori
}

{ #category : #converting }
AssociationRule >> = anObject [
	"AssociationRule inherits from Association, so we override the equality operator to test not only the equality of association's key and value, but also the equality of count, support, confidence, and lift"
	(super = anObject)
		ifFalse: [ ^ false ].
		
	^ { self count . self support . self confidence . self lift } = { anObject count . anObject support . anObject confidence . anObject lift }
]

{ #category : #converting }
AssociationRule >> asItemset [
	"Association rule can be turned into an itemset by uniting its key and value itemsets:
	(#(a b c) asItemset => #(d e) asItemset) asItemset >>> #(a b c d e) asItemset"
	
	^ self key union: self value
]

{ #category : #accessing }
AssociationRule >> confidence [
	^ confidence
]

{ #category : #accessing }
AssociationRule >> confidence: anObject [
	confidence := anObject
]

{ #category : #accessing }
AssociationRule >> count [
	^ count
]

{ #category : #accessing }
AssociationRule >> count: anObject [
	count := anObject
]

{ #category : #accessing }
AssociationRule >> lift [
	^ lift
]

{ #category : #accessing }
AssociationRule >> lift: anObject [
	lift := anObject
]

{ #category : #printing }
AssociationRule >> printOn: aStream [
	self key printOn: aStream.
	aStream nextPutAll: ' => '.
	self value printOn: aStream.
]

{ #category : #accessing }
AssociationRule >> support [
	^ support
]

{ #category : #accessing }
AssociationRule >> support: anObject [
	support := anObject
]
